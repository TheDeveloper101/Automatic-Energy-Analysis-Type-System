\section{Language and Typing}

We present a simple imperative language. 
\[
\begin{array}{lcll}
\text{Peripheral Declarations: }p & \bnfdef & \text{id} \{\langle s_{0},s_{1},\ldots,s_{n}\rangle, <, D \}, p \ \vert \ \cdot 
\end{array}
\]
\[
\begin{array}{lcll}
\text{Declarations: }d & \bnfdef & \text{fn } f(x, p) : (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \  \{c; ret := e\}, d \ \vert \ \cdot
\end{array}
\]
\[
\begin{array}{lcll}
\text{Commands: }c & \bnfdef & \text{let } x = e & \text{(let)} \\ 
  & \bnfalt &\text{let } x = f(e, p) & \text{(function call)} \\ & \bnfalt & \text{atomic}\{p_1:\Vec{s_1}, \dots, p_n:\Vec{s_n} \}(c) & \text{(atomic)} \\ 
  & \bnfalt & \text{if } e \text{ then } c_1 \text{ else } c_2 & \text{(branch)} \\ & \bnfalt & \text{transition}(x, \text{st}) & \text{(transition)} \\ & \bnfalt & \text{downgrade}(x, \text{st}) & \text{(downgrade)} \\ & \bnfalt & c_1; c_2 & \text{(command seq)}
\end{array}
\]
\[
\begin{array}{lcll}
\text{Expressions: }e & \bnfdef & x & \text{(variable)}  \\
    & \bnfalt & v & \text{(value)} \\
    & \bnfalt & e_1 \text{ binop } e_2 & \text{(binary operation)} 
\end{array}
\]
Our judgments use the following additional constructs. 
\[
\begin{array}{llcl}
\textit{Typing Context} & \tctx & \bnfdef & x \rightarrow \tau, \tctx \bnfalt \cdot
\\ 
\textit{Types} & \tau & \bnfdef & \text{int} \bnfalt \text{bool} \bnfalt \text{unit} \bnfalt \rho \bnfalt (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2})  
\\
\textit{Downgrade policy} & D & \bnfdef & s' \hookrightarrow s, D \bnfalt \cdot
\\
\textit{Peripheral Context} & \pctx & \bnfdef &  p \rightarrow \Vec{s}, \pctx \bnfalt \cdot
\end{array}
\]

A downgrade policy $s' \hookrightarrow s$ means that a peripheral in state $s'$ can transition to state $s$ assuming that $s' > s$. 
We also assume the existence of the cost functions 
$\m{cost}(s_{i},s_{j})$ = transition cost between \(s_{i},s_{j}\) when \(s_{i} \leq s_{j}\) or $\m{cost}(s_j, s_i)$ when \(s_j \hookrightarrow s_i\) and $\m{cost}(s_{i})$ = cost of being in state \(s_{i}\). Additionally, we assume $\m{cost}(\pctx)$ which returns the total cost of each peripheral being in the maximum possible state. Lastly, we define $C(\Vec{s})$ to be the symbolic cost of executing a command, but depend on some unknown peripheral states $\Vec{s}$. 
We assume that the state lattice must have a unique \(\top\) element that is
the least upper bound of all the elements. 

For atomic regions, we assume the existence of a recovery system that can bring peripherals back to the states specified at the beginning of an atomic region (like Karma for example).

\sai{state inference rules start here}

The intuition for the state inference rules is that peripherals start in an unconstrained state. Function declarations give us constraints on the input and output states of a peripheral. However those constraints may be more general than the actual state of a peripheral when the function is invoked at a function call. So we want to delay the cost determination of a function until it is actually called. To get more accurate cost bounds, we want to parameterize the cost in terms of the possible peripheral states, and then infer the smallest possible set of peripheral states at the call site that still satisfy the function declaration, and concretize the cost there.

For atomic regions, we only care about satisfying the constraints on the possible peripheral states at the start of each region.

We have the following additional inference contexts:
\[
\begin{array}{lcll}
     \textit{Constraints} & \Phi & \bnfdef & \varphi, \Phi \bnfalt \cdot  \\
    \textit{State Constraints} & \varphi & \bnfdef & \alpha = \Vec{st} \bnfalt \alpha \leq st \bnfalt \alpha \hookrightarrow st \bnfalt \alpha \subseteq \Vec{st} \bnfalt \varphi_1 \wedge \varphi_2 \bnfalt \varphi_1 \vee \varphi_2 \\
    \textit{Peripheral State Context} & A & \bnfdef & p : [\alpha], A \bnfalt \cdot
\end{array}
\]

We define [$\alpha$] to be a stack of type variables, with a lookup $A(p)$ referring to the top of it's stack, and $\alpha :: A(p)$ pushing $\alpha$ to the top of the stack. 

Let $\oplus$ to be the join between two sets of constraints $\Phi_1, \Phi_2$ and $\uplus$ to be the join between two peripheral state contexts $A_1, A_2$.

We define $\Phi(x)$ to refer to all of the constraints involving peripheral $x$. 
\milijana{what does ``associated with'' mean here?}
Given the peripheral state contexts $A_1, A_2$ associated with $\Phi_1, \Phi_2$ respectively, we define $\Phi_1 \oplus \Phi_2$ as the following.

\milijana{$\Phi$s are collections of constraints, not maps keyed on variables. how can you look up $\Phi(x)$? }

\milijana{$ A_1(x) \neq A_2(x) $ doesn't mean that the variables are different, but that the values they map to are different (I renamed the rules to make it clear). You could also say $\alpha_1 \neq \alpha_2$, which is more direct. }
\begin{mathpar}
    \inferrule*[left=Eq-Type-Variable]{
    A_1(x) = A_2(x) \\ \Phi_3(x) = \Phi_1(x) \wedge \Phi_2(x) \\ \Phi_3' = \Phi_1' \oplus \Phi_2' 
    }{
    A_1, A_2 \vdash \Phi_1(x), \Phi_1' \oplus \Phi_2(x), \Phi_2' = \Phi_3(x), \Phi_3'
    }
    
    \inferrule*[left=NotEq-Type-Variable]{
    A_1(x) \neq A_2(x) \\ A_1(x) = \alpha_1 \\ A_2(x) = \alpha_2 \\ \Phi_3(x) = \Phi_1(x) \wedge \Phi_2(x) \wedge (\alpha_3 = \alpha_1 \vee \alpha_2) \\ \Phi_3' = \Phi_1' \oplus \Phi_2' $\milijana{fresh($\alpha_3$)?}$
    }{
    A_1, A_2 \vdash \Phi_1(x), \Phi_1' \oplus \Phi_2(x), \Phi_2' = \Phi_3(x), \Phi_3'
    }
\end{mathpar}
\milijana{I think I get the point of the previous rules, though they need some tweaks. For \rulename{Eq-Type-Variable}, 
I can't quite tell what you're trying to accomplish by looking up $x$ in $\Phi$ and then joining. All constraints 
in $\Phi$ logically connected with $\land$ anyway. Can't you just return $\Phi_1 \land \Phi_2$? }


\milijana{Rn your rules are inconsistent with the meaning of $A(p)$, sometimes returning the whole stack and 
sometimes just the top element. }
We define the join between two peripheral state contexts, $A_1 \uplus A_2$ as follows.
\milijana{what is the difference between the $\alpha' = \alpha_1 \lor \alpha_2$ here and $\alpha_3 = \alpha_1 \lor \alpha_2$ from \rulename{NotEq-Type-Variable?}}
\begin{mathpar}
\inferrule*[left=Context Join]
{
A_1(p) = \alpha_1 :: A_1'(p) \\
A_2(p) = \alpha_2 :: A_2'(p) \\
\alpha' \text{ fresh} \\ \alpha' = \alpha_1 \vee \alpha_2 \\ A' = A_1' \uplus A_2'
}
{
A_1 \uplus A_2 = \alpha' :: A'(p)
}

\inferrule*[left=Empty]
{  }
{
\cdot \uplus \cdot = \cdot
}

\inferrule*[left=One Side Empty]
{ }
{A_1 \uplus \cdot = A_1}

\inferrule*[left=Symmetry]
{ }
{A_1 \uplus A_2 = A_2 \uplus A_1}
\end{mathpar}

Command state inference rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, A, \Phi \vdash c \rightarrow A', \Phi'$}
\end{aligned}
$$



\begin{mathpar}
\inferrule*[left=T-Transition\(_\textit{inf}\)] 
{ \tctx, A, \Phi \vdash x : \rho \\ A(x) = \alpha_0 \\ \alpha_1 \text{ fresh} \\ \Phi' = \Phi, \alpha_0 \leq st, \alpha_1 = st \\ A'(x) = \alpha_1 :: A(x)
} 
{ 
\tctx, A,\Phi \vdash \text{transition}(x, st) : \text{unit} \rightarrow A', \Phi' 
}

\inferrule*[left=T-Downgrade\(_\textit{inf}\)]
{
\tctx, A, \Phi \vdash x : \rho \\ A(x) = \alpha_0 \\ \alpha_1 \text{ fresh} \\ \Phi' = \Phi, \alpha_0 \hookrightarrow st, \alpha_1 = st \\ A'(x) = \alpha_1 :: A(x)
}
{ 
\tctx, A, \Phi \vdash \text{downgrade}(x, st) : \text{unit} \rightarrow A', \Phi'
}

\inferrule*[left=T-If\(_\textit{inf}\)]
{
\tctx \vdash e : \text{bool} \\ \tctx, A, \Phi \vdash c_1 : \rightarrow A_1, \Phi_1\\ \tctx, A, \Phi \vdash c_2 \rightarrow A_2, \Phi_2 \\ \Phi^* = \Phi_1 \oplus \Phi_2 \\ A^* = A_1 \uplus A_2
}
{
\tctx, A, \Phi \vdash \text{if } e \text{ then } c_1 \text{ else } c_2: \tau \xrightarrow{C} A^*, \Phi^*
}

\inferrule*[left=T-Seq\(_\textit{inf}\)]
{
\tctx, A, \Phi \vdash c_1 \rightarrow A', \Phi' \\ \tctx, A', \Phi' \vdash c_2 \rightarrow A'', \Phi''
}
{
\tctx, A, \Phi \vdash c_1; c_2 \rightarrow A'', \Phi''
}

\inferrule*[left=T-Call\(_\textit{inf}\)]
{
\tctx(f) = (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \\ \tctx \vdash e : \tau_1 \\ A(p) = \alpha \\ \alpha' \text{ fresh} \\ \Phi' = \Phi, \alpha \subseteq \Vec{s_1}, \alpha' \subseteq \Vec{s_2} \\ A'(p) = \alpha' :: A(p)
}
{
\tctx, A, \Phi \vdash \text{let } x = f(e, p) \rightarrow A', \Phi'
}

\inferrule*[left=T-Atomic\(_\textit{inf}\)]
{
\forall i \in [1, \dots, n], A(p_i) = \alpha_i \\ \varphi = \bigwedge_{i = 1}^n \alpha_i \subseteq \Vec{s_i} \\ \Phi^* = \Phi \wedge \varphi \\ \tctx, A, \Phi^* \vdash c \rightarrow A', \Phi'
}
{
\tctx, A, \Phi \vdash \text{atomic}\{p_1: \Vec{s_1}, \dots, p_n: \Vec{s_n} \}(c) \rightarrow A', \Phi'
}
\end{mathpar}

\sai{state inference rules end here}

\sai{AARA system starts here}


Command typing rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, \pctx \vdash c: \tau \xrightarrow{C} \tctx', \pctx'$}
\end{aligned}
$$

Expression typing rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, \pctx \vdash e: \tau, C $}
\end{aligned}
$$


\begin{mathpar}

\inferrule*[left=T-Var]
{ \tctx(x) = \tau }
{ \tctx, \pctx \vdash x : \tau, C_v }


\inferrule*[left=T-BinOp]
{
\tctx,\pctx \vdash e_1 : \tau_1, C_1 \\ \tctx,\pctx \vdash e_2 : \tau_2, C_2 \\ \text{binop} : \tau_1 \times \tau_2 \xrightarrow{C_b} \tau
}
{
\tctx,\pctx \vdash e_1 \ \text{binop}\ e_2 : \tau, C_1 + C_2 + C_b
}

\inferrule*[left=T-PeriphDecl]
{
| \langle s_0,\ldots s_n \rangle | \geq 1 \\ \forall s' \hookrightarrow s \in D, s' > s
}
{
\tctx, \pctx \vdash \text{id} \{\langle s_{0},s_{1},\ldots,s_{n}\rangle, <, D \} : \text{unit} \Rightarrow \tctx[\text{id} : \rho], \pctx
}

\inferrule*[left=T-Let]
{ \tctx,\pctx \vdash e : \tau, C_e }
{ 
\tctx,\pctx \vdash \text{let } x = e : \text{unit} \xrightarrow{C_l + C_e} \tctx[x : \tau] , \pctx
}

\inferrule*[left=T-Call]
{
\tctx(f) = (\tau_1, \Vec{s_1}) \xrightarrow{\Phi_f} (\tau_2, \Vec{s_2}) \\ \tctx,\pctx \vdash e : \tau_1 \\ \pctx(p) = \Vec{s} \\ \Vec{s} \subseteq s_1 \\ C_f = \Phi_f[\Vec{s}] \\ C = C_f + C_a + \max(\forall s_i \in \Vec{s}, \m{cost}(s_i, s_1))
}
{
\tctx,\pctx \vdash \text{let } x = f(e, p) : \text{unit} \xrightarrow{C} \tctx[x : \tau_2], \pctx[p: s_2]
}

\inferrule*[left=T-Transition]
{
\tctx,\pctx \vdash x : \rho \\ \pctx(x) = \Vec{s} \\ \forall s_i\in \Vec{s}, s_i \leq st \\ C = \max(\forall s_i \in \Vec{s}, \m{cost}(s_i, st))
}
{ 
\tctx,\pctx \vdash \text{transition}(x, st) : \text{unit} \xrightarrow{C} \tctx, \pctx[x : st]
}

\inferrule*[left=T-Downgrade]
{
\tctx,\pctx \vdash x : \rho \\ \pctx(x) = \Vec{s} \\ \forall s_i\in \Vec{s}, s_i \hookrightarrow st \in p(D) \\ C = \max (\forall s_i \in \Vec{s}, \m{cost}(s_i, st) )
}
{ 
\tctx,\pctx \vdash \text{downgrade}(x, st) : \text{unit} \xrightarrow{C} \tctx, \pctx[x : st]
}

\inferrule*[left=T-If]
{
\tctx,\pctx \vdash e : \text{bool} \\ \tctx,\pctx \vdash c_1 : \tau \xrightarrow{C_1} \tctx_1, \pctx_1 \\ \tctx,\pctx \vdash c_2 : \tau \xrightarrow{C_2} \tctx_2, \pctx_2 \\ \tctx^* = \tctx_1 \cup \tctx_2 \\ \pctx^* = \pctx_1 \cup \pctx_2 \\ C = \max(C_1, C_2)
}
{
\tctx, \pctx \vdash \text{if } e \text{ then } c_1 \text{ else } c_2: \tau \xrightarrow{C} \tctx^*, \pctx^*
}
\end{mathpar}
\begin{mathpar}
\inferrule*[left=T-Seq]
{
\tctx,\pctx \vdash c_1 : \tau_1 \xrightarrow{C'} \tctx', \pctx' \\ \tctx',\pctx' \vdash c_2 : \tau_2 \xrightarrow{C''} \tctx'', \pctx'' \\ C'_{\max} = \m{cost}(\pctx') \\ C = C' + C'' + C'_{\max}
}
{
\tctx,\pctx \vdash c_1 ; c_2 : \tau_2 \xrightarrow{C} \tctx'', \pctx''
}

\inferrule*[left=T-Atomic]
{
\forall i, \pctx(p_i) \subseteq \Vec{s_i} \\ \tctx,\pctx \vdash c : \tau \xrightarrow{C'} \tctx', \pctx' \\ C = [\sum_{i=1}^{n} \max(\forall s'_i \in \Vec{s_i}, \m{cost(s'_i)})] + C'
}
{ 
\tctx,\pctx \vdash \text{atomic}\{p_1: \Vec{s_1}, \dots, p_n: \Vec{s_n} \}(c) : \tau \xrightarrow{C} \tctx', \pctx'
}


    \inferrule*[left=T-FunDecl]
{
\tctx[x : \tau_1], \pctx[p: \Vec{s_1}] \vdash c: \tau' \xrightarrow{C_1} \tctx', \pctx' \\ \pctx'(p) = \Vec{s_2} \\ \tctx', \pctx' \vdash e : \tau_2, C_2 \\ \Phi_f = C_1(\Vec{s_1}) + C_2(\Vec{s_1})
}
{ \tctx,\pctx \vdash \text{fn } f(x, p) : (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \  \{c; ret := e\} \Rightarrow \tctx[f \mapsto (\tau_1, \Vec{s_1}) \xrightarrow{\Phi_f} (\tau_2, \Vec{s_2})], \pctx
}

\end{mathpar}
\sai{AARA system ends here}
\newpage
\sai{Typestate system starts here}

Command typing rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, \pctx \vdash c: \tau \Rightarrow \tctx', \pctx'$}
\end{aligned}
$$

Expression typing rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, \pctx \vdash e: \tau $}
\end{aligned}
$$

\begin{mathpar}

\inferrule*[left=T-Var]
{ \tctx(x) = \tau }
{ \tctx, \pctx \vdash x : \tau }


\inferrule*[left=T-BinOp]
{
\tctx,\pctx \vdash e_1 : \tau_1 \\ \tctx,\pctx \vdash e_2 : \tau_2 \\ \text{binop} : \tau_1 \times \tau_2 \to \tau
}
{
\tctx,\pctx \vdash e_1 \ \text{binop}\ e_2 : \tau
}

\inferrule*[left=T-Let]
{ \tctx,\pctx \vdash e : \tau }
{ 
\tctx,\pctx \vdash \text{let } x = e : \text{unit} \Rightarrow \tctx[x : \tau] , \pctx
}

\inferrule*[left=T-Call]
{
\tctx(f) = (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \\ \tctx,\pctx \vdash e : \tau_1 \\ \pctx(p) = \Vec{s} \\ \Vec{s} \subseteq s_1
}
{
\tctx,\pctx \vdash \text{let } x = f(e, p) : \text{unit} \Rightarrow \tctx[x : \tau_2], \pctx[p: s_2]
}

\inferrule*[left=T-Transition]
{
\tctx,\pctx \vdash x : \rho \\ \pctx(x) = \Vec{s} \\ \forall s_i\in \Vec{s}, s_i \leq st
}
{ 
\tctx,\pctx \vdash \text{transition}(x, st) : \text{unit} \Rightarrow \tctx, \pctx[x : st]
}

\inferrule*[left=T-Downgrade]
{
\tctx,\pctx \vdash x : \rho \\ \pctx(x) = \Vec{s} \\ \forall s_i\in \Vec{s}, s_i \hookrightarrow st \in p(D)
}
{ 
\tctx,\pctx \vdash \text{downgrade}(x, st) : \text{unit} \Rightarrow \tctx, \pctx[x : st]
}

\inferrule*[left=T-If]
{
\tctx,\pctx \vdash e : \text{bool} \\ \tctx,\pctx \vdash c_1 : \tau \Rightarrow \tctx_1, \pctx_1 \\ \tctx,\pctx \vdash c_2 : \tau \Rightarrow \tctx_2, \pctx_2 \\ \tctx^* = \tctx_1 \cup \tctx_2 \\ \pctx^* = \pctx_1 \cup \pctx_2 
}
{
\tctx, \pctx \vdash \text{if } e \text{ then } c_1 \text{ else } c_2 \Rightarrow \tctx^*, \pctx^*
}

\inferrule*[left=T-Seq]
{
\tctx,\pctx \vdash c_1 : \tau_1 \Rightarrow \tctx', \pctx' \\ \tctx',\pctx' \vdash c_2 : \tau_2 \Rightarrow \tctx'', \pctx''
}
{
\tctx,\pctx \vdash c_1 ; c_2 : \tau_2 \Rightarrow \tctx'', \pctx''
}

\inferrule*[left=T-Atomic]
{
\forall i, \pctx(p_i) \subseteq \Vec{s_i} \\ \tctx,\pctx \vdash c : \tau \Rightarrow \tctx', \pctx' 
}
{ 
\tctx,\pctx,S \vdash \text{atomic}\{p_1: \Vec{s_1}, \dots, p_n: \Vec{s_n} \}(c) : \tau \Rightarrow \tctx', \pctx'
}

\inferrule*[left=T-FunDecl]
{
\tctx[x : \tau_1], \pctx[p: \Vec{s_1}] \vdash c: \tau_2 \Rightarrow \tctx', \pctx' \\ \pctx'(p) = \Vec{s_2} \\ \tctx', \pctx' \vdash e : \tau_2
}
{ \tctx,\pctx \vdash \text{fn } f(x, p) : (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \  \{c; ret := e\} \Rightarrow \tctx[f \mapsto (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2})], \pctx
}

\end{mathpar}

\sai{Typestate system ends here}