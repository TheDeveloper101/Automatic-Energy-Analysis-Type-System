\section{Language and Typing}

We present a simple imperative language. 
\[
\begin{array}{lcll}
\text{Instructions: }i & \bnfdef & x & \text{(variable)}  \\
    & \bnfalt & v & \text{(value)} \\
    & \bnfalt & i_1 \text{ binop } i_2 & \text{(binary operation)} \\
    & \bnfalt & \text{transition}(x, \text{st}) & \text{(transition)} \\
    & \bnfalt & i_1; \ i_2 & \text{(instruction seq)}
\end{array}
\]
\[
\begin{array}{lcll}
\text{Expressions: }e & \bnfdef & i & \text{(instruction)} \\ & \bnfalt & \text{let } x = i & \text{(let)} \\
  & \bnfalt & e_1\ e_2 & \text{(application)} \\
  & \bnfalt & \lambda x.\,i & \text{(function abstraction)} \\
  & \bnfalt & \text{share } x \text{ as } x_1, x_2 \text{ in } e & \text{(share)} \\
  & \bnfalt & \text{atomic}(i) & \text{(atomic)} \\
  & \bnfalt & \text{if } i \text{ then } e_1 \text{ else } e_2 & \text{(branch)} 
\end{array}
\]

Our judgments use the following additional constructs. 
\[
\begin{array}{llcl}
\textit{Typing Context} & \tctx & \bnfdef & x \rightarrow \tau, \tctx \bnfalt \cdot
\\ 
\textit{Types} & \tau & \bnfdef & \text{int} \bnfalt \text{bool} \bnfalt \tau_1 \rightarrow \tau_2 \bnfalt \rho 
\\
\textit{Peripheral} & p & \bnfdef & (\langle s_{0},s_{1},\ldots,s_{n}\rangle, <, D)
\\
\textit{Downgrade policy} & D & \bnfdef & \langle (s_i, s_j), \ldots \rangle
\\
\textit{Peripheral Context} & \pctx & \bnfdef &  p \rightarrow s_{\mt{curr}}, \pctx \bnfalt \cdot
\end{array}
\]
\sai{I found this paper: "Security Policies for Downgrading" which discusses Security policies for declassification. The paper discusses how one can allow for declassification to happen when a condition is met. Right now, I define a "downgrade policy" to just be pairs of states such that the peripheral can transition backwards from the higher state into the lower state. But, real peripherals also automatically lower their state once they complete an operation. One example would be a radio that starts in an idle state, performs a receive operation and then goes back to idle before the function ends. In this case, one could specify this as a downgrade policy that gets triggered on the condition that the receive operation completed successfully, which I think works well with intermittent computing.}
We also assume the existence of the cost functions 
$\m{cost}(s_{i},s_{j})$ = transition cost between \(s_{i},s_{j}\) when
\(s_{i} \leq s_{j}\) and 
$\m{cost}(s_{i})$ = cost of being in state \(s_{i}\).
We define a join between the peripheral typing contexts $\pctx_1 \lub \pctx_2$ as follows.
\begin{mathpar}
\inferrule{
    s_3 = s_1 \lub s_2 \\ \pctx_3 = \pctx_1' \lub \pctx_2' \\ \m{dom}(\pctx_1') = \m{dom}(\pctx_2') 
}
{  p \rightarrow (S,s_1), \pctx_1' \lub p \rightarrow (S,s_2), \pctx_2' = p \rightarrow (S, s_3), \pctx_3 }
\end{mathpar}
where the $s_1 \lub s_2$ is a standard notion of a lattice join, that is, 
\(s_{i} \lub s_{j} = s_{j}\) if \(s_{i} < s_{j}\), where the state lattice must have a unique \(\top\) element that is
the least upper bound of all the elements.
In words, the join of two peripheral contexts is a new context whose
elements are the join of the current state of each peripheral in the
context, and $\m{dom}(\pctx') = \m{dom}(\pctx'')$.

For now, we will assume that we only have one peripheral.
\sai{I believe that we want to track the set of the potential states a peripheral could be in, and check that every transition is valid when we perform a transition. Also, do we need a separate rule for downgrading, or can we "overload" transition to have a separate rule for the assumption that we are attempting to downgrade}
\todo{finish updating rules and add in extra rules for the remaining language constructs.}
\begin{mathpar}
\inferrule*[right=T-Seq]
{
  \tctx, \pctx, s_{\max} \vdash e_1 : \tau_1 \xrightarrow{C_1} \pctx', s'_{\max} \\
  C_{1\text{-max}} = \text{cost}(s_{\max}) \\
  \tctx, \pctx', s'_{\max} \vdash e_2 : \tau_2 \xrightarrow{C_2} \pctx'', s''_{\max} \\
  C_{2\text{-max}} = \text{cost}(s'_{\max}) \\
  C = C_1 + C_2 + C_{1\text{-max}} + C_{2\text{-max}}
}
{
  \tctx, \pctx, s_{\max} \vdash i_1; i_2 : \tau_2 \xrightarrow{C} \pctx'', s''_{\max}
}

\inferrule*[right=T-Atomic]
{
  \tctx, \pctx, s_{\max} \vdash i : \tau \xrightarrow{C_1} \pctx', s'_{\max} \\
  C_{\max} = \text{cost}(s'_{\max}) \\
  C = C_1 + C_{\max}
}
{
  \tctx, \pctx, s_{\max} \vdash \text{atomic}(i) : \tau \xrightarrow{C} \pctx', s'_{\max}
}

\inferrule*[right=T-Branch]
{
  \tctx, \pctx, s_{\max} \vdash i : \text{bool} \xrightarrow{C'} \pctx, s_{\max} \\
  \tctx, \pctx, s_{\max} \vdash e_1 : \tau \xrightarrow{C_1} \pctx_1, s^1_{\max} \\
  \tctx, \pctx, s_{\max} \vdash e_2 : \tau \xrightarrow{C_2} \pctx_2, s^2_{\max}\\
  C = C' + \max(C_1, C_2) \\
  \pctx' = \pctx_1 \sqcup \pctx_2 \\
  s'_{\max} = s^1_{\max} \lub s^2_{\max}
}
{
  \tctx, \pctx, s_{\max} \vdash \text{if } i \text{ then } e_1 \text{ else } e_2 : \tau \xrightarrow{C} \pctx', s'_{\max}
}

\inferrule*[right=T-Transition]
{
  \tctx, \pctx \vdash x : \rho \\
  \pctx(x) = s_i \\
  s_i \le s \\
  C_t = \text{cost}(s_i, s) \\ s'_{\max} = s_{\max} \lub s
}
{
  \tctx, \pctx, s_{\max} \vdash \text{transition}(x, s) : \text{Unit} \xrightarrow{C_t} \pctx[x : s], s'_{\max}
}

\inferrule*[right=T-Binop]
{
\tctx, \pctx, s_{\max} \vdash e_1 : \text{int} \xrightarrow{C_1} \pctx, s_{\max} \\ \tctx, \pctx, s_{\max} \vdash e_2 : \tau \xrightarrow{C_2} \pctx, s_{\max} \\
C = C_1 + C_2 + C_{bin}
}
{
\tctx, \pctx, s_{\max} \vdash i_1 \text{ binop } i_2 : \tau \xrightarrow{C} \pctx, s_{\max}
}

\inferrule*[right=T-Var]
{
  \tctx(x) = \tau
}
{
\tctx,\pctx,s_{\max} \vdash x : \tau \xrightarrow{C_v} \pctx, s_{\max}
}

\end{mathpar}
