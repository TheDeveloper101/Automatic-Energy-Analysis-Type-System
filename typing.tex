\section{Language and Typing}

We present a simple imperative language. 
\[
\begin{array}{lcll}
\text{Declarations: }d & \bnfdef & c & \text{(command)} \\ & \bnfalt & \text{fn } f(x_{i}) : v_{r} \ \{c\} & \text{(function)} \\ & \bnfalt & d_1 \ d_2 & \text{(sequence)}
\end{array}
\]
\[
\begin{array}{lcll}
\text{Commands: }c & \bnfdef & e & \text{(expression)} \\ & \bnfalt & \text{let } x = e & \text{(let)} \\ 
  & \bnfalt &\text{let } x = f(e) & \text{(function call)} \\ & \bnfalt & \text{atomic}(c) & \text{(atomic)} \\
  & \bnfalt & \text{share } x \text{ as } x_1, x_2 \text{ in } c & \text{(share)} \\ 
  & \bnfalt & \text{if } e \text{ then } c_1 \text{ else } c_2 & \text{(branch)} \\ & \bnfalt & \text{transition}(x, \text{st}) & \text{(transition)} \\ & \bnfalt & \text{downgrade}(x, \text{st}) & \text{(downgrade)} \\ & \bnfalt & c_1; c_2 & \text{(command seq)}
\end{array}
\]
\[
\begin{array}{lcll}
\text{Expressions: }e & \bnfdef & x & \text{(variable)}  \\
    & \bnfalt & v & \text{(value)} \\
    & \bnfalt & e_1 \text{ binop } e_2 & \text{(binary operation)} 
\end{array}
\]

Our judgments use the following additional constructs. 
\[
\begin{array}{llcl}
\textit{Typing Context} & \tctx & \bnfdef & x \rightarrow \tau, \tctx \bnfalt \cdot
\\ 
\textit{Types} & \tau & \bnfdef & \text{int} \bnfalt \text{bool} \bnfalt \text{unit} \bnfalt \rho \bnfalt (\tau_1, s_1) \rightarrow (\tau_2, s_2)  
\\
\textit{Peripheral} & p & \bnfdef & (\langle s_{0},s_{1},\ldots,s_{n}\rangle, <, D)
\\
\textit{Downgrade policy} & D & \bnfdef & s' \hookrightarrow s, D \bnfalt \cdot
\\
% \textit{Downgrade condition} & q & \bnfdef & b \bnfalt \textbf{t} \bnfalt \textbf{f} \bnfalt q_1 \land q_2 \bnfalt \neg q \bnfalt q_1 \lor q_2
% \\
\textit{Peripheral Context} & \pctx & \bnfdef &  p \rightarrow s_{\mt{curr}}, \pctx \bnfalt \cdot
\\
\textit{Potential States} & S & \bnfdef & p \rightarrow (s_{pos}), S \bnfalt \cdot
\end{array}
\]

A downgrade policy $s' \hookrightarrow s$ means that a peripheral in state $s'$ can transition to state $s$ assuming that $s' > s$. We keep track of the potential states a peripheral could be in using $S$. 
$\m{max}(S)$ will return the maximum possible state of each peripheral.
We also assume the existence of the cost functions 
$\m{cost}(s_{i},s_{j})$ = transition cost between \(s_{i},s_{j}\) when \(s_{i} \leq s_{j}\) and $\m{cost}(s_{i})$ = cost of being in state \(s_{i}\). Finally, $\m{cost}(\m{max}(S))$ = the sum of the cost of being in the maximum state for each peripheral. 
We define a join between the peripheral typing contexts $\pctx_1 \lub \pctx_2$ as follows.
\begin{mathpar}
\inferrule{
    s_3 = s_1 \lub s_2 \\ \pctx_3 = \pctx_1' \lub \pctx_2' \\ \m{dom}(\pctx_1') = \m{dom}(\pctx_2') 
}
{  p \rightarrow s_1, \pctx_1' \lub p \rightarrow s_2, \pctx_2' = p \rightarrow s_3, \pctx_3 }
\end{mathpar}
where the $s_1 \lub s_2$ is a standard notion of a lattice join, that is, 
\(s_{i} \lub s_{j} = s_{j}\) if \(s_{i} < s_{j}\), where the state lattice must have a unique \(\top\) element that is
the least upper bound of all the elements.
In words, the join of two peripheral contexts is a new context whose
elements are the join of the current state of each peripheral in the
context, and $\m{dom}(\pctx') = \m{dom}(\pctx'')$.

For now, we will assume that we only have one peripheral.

\sai{Typestate system starts here}

\begin{mathpar}

\inferrule*[left=T-Var]
{ \tctx(x) = \tau }
{ \tctx, \pctx, S \vdash x : \tau }


\inferrule*[left=T-BinOp]
{
\tctx,\pctx,S \vdash e_1 : \tau_1 \\ \tctx,\pctx,S \vdash e_2 : \tau_2 \\ \text{binop} : \tau_1 \times \tau_2 \to \tau
}
{
\tctx,\pctx,S \vdash e_1 \ \text{binop}\ e_2 : \tau
}


\inferrule*[left=T-Let]
{ \tctx,\pctx,S \vdash e : \tau }
{ 
\tctx,\pctx,S \vdash \text{let } x = e : \text{unit} \Rightarrow \tctx[x : \tau] , \pctx, S
}

\inferrule*[left=T-Call]
{
\tctx(f) = (\tau_1, s_1) \rightarrow (\tau_2, s_2) \\ \tctx,\pctx,S \vdash e : \tau_1 \\ \pctx(p) = s_1 
}
{
\tctx,\pctx,S \vdash \text{let } x = f(e, p) : \text{unit} \Rightarrow \tctx[x : \tau_2], \pctx[p: s_2], S[p \mapsto s_2 \cup \{s_{pos}\}]
}

\inferrule*[left=T-Transition]
{
\tctx,\pctx, S \vdash x : \rho \\ \pctx(x) = s_i \\ s_i \leq st 
}
{ 
\tctx,\pctx,S \vdash \text{transition}(x, st) : \text{unit} \Rightarrow \tctx, \pctx[x : st], S[p \mapsto st \cup \{s_{pos}\}]
}

\inferrule*[left=T-Downgrade]
{
\tctx,\pctx, S \vdash x : \rho \\ \pctx(x) = s_i \\ st \hookrightarrow s_i \in p(D)
}
{ 
\tctx,\pctx,S \vdash \text{downgrade}(x, st) : \text{unit} \Rightarrow \tctx, \pctx[x : st], S[p \mapsto s' \cup \{s_{pos}\}]
}

\inferrule*[left=T-If]
{
\tctx,\pctx,S \vdash e : \text{bool} \\ \tctx,\pctx,S \vdash c_1 : \tau \Rightarrow \tctx', \pctx', S' \\ \tctx,\pctx,S \vdash c_2 : \tau \Rightarrow \tctx'', \pctx'', S'' \\ \tctx* = \tctx' \cup \tctx'' \\ \pctx* = \pctx' \lub \pctx'' \\ S* = S' \cup S''
}
{ 
\tctx,\pctx,S \vdash \text{if } e \texttt{ then } c_1 \text{ else } c_2 : \tau \Rightarrow \tctx*, \pctx*, S*
}

\inferrule*[left=T-Seq]
{
\tctx,\pctx,S \vdash c_1 : \tau_1 \Rightarrow \tctx', \pctx', S' \\ \tctx',\pctx',S' \vdash c_2 : \tau_2 \Rightarrow \tctx'', \pctx'', S''
}
{
\tctx,\pctx,S \vdash c_1 ; c_2 : \tau_2 \Rightarrow \tctx'', \pctx'', S''
}

\inferrule*[left=T-Atomic]
{
\tctx,\pctx,S \vdash c : \tau \Rightarrow \tctx', \pctx', S'
}
{ 
\tctx,\pctx,S \vdash \text{atomic}(c) : \tau \Rightarrow \tctx', \pctx', S'
}

\inferrule*[left=T-FunDecl]
{
\tctx[x_a : \tau_1], \pctx[p: s_1], S \vdash c: \tau_2 \Rightarrow \tctx', \pctx[p : s_2], S'
}
{ \tctx,\pctx,S \vdash \text{fn } f(x_a, p) : v_r \ \{ c \} \Rightarrow \tctx[f \mapsto (\tau_1, s_1) \rightarrow (\tau_2, s_2)], \pctx, S
}

\end{mathpar}

\sai{Typestate system ends here}


\begin{mathpar}
\inferrule*[right=T-FunDecl]
{
  \tctx, x:\tau_1, \pctx, S_f^{in} \vdash c : \tau_2 \xrightarrow{C_f} \pctx', S_f^{out} 
}
{
  \tctx, \pctx, S \vdash
  \text{fn }f(x:\tau_1) : \tau_2 \ \{c\} : 
  \Gamma[f \mapsto (\tau_1, S_f^{in}) \xrightarrow{C_f} (\tau_2, S_f^{out})],
  \pctx, S
}

\inferrule*[right=T-Call]
{
  \tctx(f) = (\tau_1, S_f^{in}) \xrightarrow{C_f} (\tau_2, S_f^{out}) \\ 
  S_c = \mathsf{unify}(S,\, S_f^{in}) \\ \tctx,\pctx,S_c \vdash e : \xrightarrow{C_e} \tau_1, \pctx, S'_c 
  \\ C = C_f + C_e + \m{cost} (\max (S'_c) )
}
{
  \tctx, \pctx, S \vdash \text{let } x = f(e) : \tau_2, \xrightarrow{C} \tctx[x \mapsto \tau_2], \pctx', S'_c
}

\sai{don't read past here}

\inferrule*[right=T-Seq]
{
  \tctx, \pctx, s_{\max} \vdash e_1 : \tau_1 \xrightarrow{C_1} \pctx', s'_{\max} \\
  C_{1\text{-max}} = \text{cost}(s_{\max}) \\
  \tctx, \pctx', s'_{\max} \vdash e_2 : \tau_2 \xrightarrow{C_2} \pctx'', s''_{\max} \\
  C_{2\text{-max}} = \text{cost}(s'_{\max}) \\
  C = C_1 + C_2 + C_{1\text{-max}} + C_{2\text{-max}}
}
{
  \tctx, \pctx, s_{\max} \vdash i_1; i_2 : \tau_2 \xrightarrow{C} \pctx'', s''_{\max}
}

\inferrule*[right=T-Atomic]
{
  \tctx, \pctx, s_{\max} \vdash i : \tau \xrightarrow{C_1} \pctx', s'_{\max} \\
  C_{\max} = \text{cost}(s'_{\max}) \\
  C = C_1 + C_{\max}
}
{
  \tctx, \pctx, s_{\max} \vdash \text{atomic}(i) : \tau \xrightarrow{C} \pctx', s'_{\max}
}

\inferrule*[right=T-Branch]
{
  \tctx, \pctx, s_{\max} \vdash i : \text{bool} \xrightarrow{C'} \pctx, s_{\max} \\
  \tctx, \pctx, s_{\max} \vdash e_1 : \tau \xrightarrow{C_1} \pctx_1, s^1_{\max} \\
  \tctx, \pctx, s_{\max} \vdash e_2 : \tau \xrightarrow{C_2} \pctx_2, s^2_{\max}\\
  C = C' + \max(C_1, C_2) \\
  \pctx' = \pctx_1 \sqcup \pctx_2 \\
  s'_{\max} = s^1_{\max} \lub s^2_{\max}
}
{
  \tctx, \pctx, s_{\max} \vdash \text{if } i \text{ then } e_1 \text{ else } e_2 : \tau \xrightarrow{C} \pctx', s'_{\max}
}

\inferrule*[right=T-Transition]
{
  \tctx, \pctx \vdash x : \rho \\
  \pctx(x) = s_i \\
  s_i \le s \\
  C_t = \text{cost}(s_i, s) \\ s'_{\max} = s_{\max} \lub s
}
{
  \tctx, \pctx, s_{\max} \vdash \text{transition}(x, s) : \text{Unit} \xrightarrow{C_t} \pctx[x : s], s'_{\max}
}

\inferrule*[right=T-Binop]
{
\tctx, \pctx, s_{\max} \vdash e_1 : \text{int} \xrightarrow{C_1} \pctx, s_{\max} \\ \tctx, \pctx, s_{\max} \vdash e_2 : \tau \xrightarrow{C_2} \pctx, s_{\max} \\
C = C_1 + C_2 + C_{bin}
}
{
\tctx, \pctx, s_{\max} \vdash i_1 \text{ binop } i_2 : \tau \xrightarrow{C} \pctx, s_{\max}
}

\inferrule*[right=T-Var]
{
  \tctx(x) = \tau
}
{
\tctx,\pctx,s_{\max} \vdash x : \tau \xrightarrow{C_v} \pctx, s_{\max}
}

\end{mathpar}





