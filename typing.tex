\section{Language and Typing}

We present a simple imperative language. 
\[
\begin{array}{lcll}
\text{Peripheral Declarations: }p & \bnfdef & \text{id} \{\langle s_{0},s_{1},\ldots,s_{n}\rangle, <, D \}, p \ \vert \ \cdot 
\end{array}
\]
\[
\begin{array}{lcll}
\text{Declarations: }d & \bnfdef & \text{fn } f(x, p) : (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \  \{c; ret := e\}, d \ \vert \ \cdot
\end{array}
\]
\[
\begin{array}{lcll}
\text{Commands: }c & \bnfdef & \text{let } x = e & \text{(let)} \\ 
  & \bnfalt &\text{let } x = f(e, p) & \text{(function call)} \\ & \bnfalt & \text{atomic}\{p_1:\Vec{s_1}, \dots, p_n:\Vec{s_n} \}(c) & \text{(atomic)} \\ 
  & \bnfalt & \text{if } e \text{ then } c_1 \text{ else } c_2 & \text{(branch)} \\ & \bnfalt & \text{transition}(x, \text{st}) & \text{(transition)} \\ & \bnfalt & \text{downgrade}(x, \text{st}) & \text{(downgrade)} \\ & \bnfalt & c_1; c_2 & \text{(command seq)}
\end{array}
\]
\[
\begin{array}{lcll}
\text{Expressions: }e & \bnfdef & x & \text{(variable)}  \\
    & \bnfalt & v & \text{(value)} \\
    & \bnfalt & e_1 \text{ binop } e_2 & \text{(binary operation)} 
\end{array}
\]
Our judgments use the following additional constructs. 
\[
\begin{array}{llcl}
\textit{Typing Context} & \tctx & \bnfdef & x \rightarrow \tau, \tctx \bnfalt \cdot
\\ 
\textit{Types} & \tau & \bnfdef & \text{int} \bnfalt \text{bool} \bnfalt \text{unit} \bnfalt \rho \bnfalt (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2})  
\\
\textit{Downgrade policy} & D & \bnfdef & s' \hookrightarrow s, D \bnfalt \cdot
\\
\textit{Peripheral Context} & \pctx & \bnfdef &  p \rightarrow \Vec{s}, \pctx \bnfalt \cdot
\end{array}
\]

A downgrade policy $s' \hookrightarrow s$ means that a peripheral in state $s'$ can transition to state $s$ assuming that $s' > s$. 
We also assume the existence of the cost functions 
$\m{cost}(s_{i},s_{j})$ = transition cost between \(s_{i},s_{j}\) when \(s_{i} \leq s_{j}\) or $\m{cost}(s_j, s_i)$ when \(s_j \hookrightarrow s_i\) and $\m{cost}(s_{i})$ = cost of being in state \(s_{i}\). Additionally, we assume $\m{cost}(\pctx)$ which returns the total cost of each peripheral being in the maximum possible state. Lastly, we define $C(\Vec{s})$ to be the symbolic cost of executing a command, but depend on some unknown peripheral states $\Vec{s}$. 
We assume that the state lattice must have a unique \(\top\) element that is
the least upper bound of all the elements. 

For atomic regions, we assume the existence of a recovery system that can bring peripherals back to the states specified at the beginning of an atomic region (like Karma for example).

\sai{state inference rules start here}

The intuition for the state inference rules is that peripherals start in an unconstrained state. Function declarations give us constraints on the input and output states of a peripheral. However those constraints may be more general than the actual state of a peripheral when the function is invoked at a function call. So we want to delay the cost determination of a function until it is actually called. To get more accurate cost bounds, we want to parameterize the cost in terms of the possible peripheral states, and then infer the smallest possible set of peripheral states at the call site that still satisfy the function declaration, and concretize the cost there.

For atomic regions, we only care about satisfying the constraints on the possible peripheral states at the start of each region.

We have the following additional inference contexts:
\[
\begin{array}{lcll}
     \textit{Constraints} & \Phi & \bnfdef & \varphi, \Phi \bnfalt \cdot  \\
    \textit{State Constraints} & \varphi & \bnfdef & \alpha = \Vec{st} \bnfalt \alpha \leq st \bnfalt \alpha \hookrightarrow st \bnfalt \alpha \subseteq \Vec{st} \bnfalt \varphi_1 \wedge \varphi_2 \bnfalt \varphi_1 \vee \varphi_2 \\
    \textit{Peripheral State Context} & A & \bnfdef & p : [\alpha], A \bnfalt \cdot
\end{array}
\]

We define [$\alpha$] to be a stack of type variables, with a lookup $A(p)$ referring to the top of it's stack, $\alpha :: A(p)$ pushing $\alpha$ to the top of the stack and $A[p]$ to refer to the current stack of type variables for peripheral $p$. We also define $\m{prefix}(A_1, A_2)$ to return the common prefix of two contexts $A_1, A_2$ if one exists, or $\cdot$ if none exists.

Let $\oplus$ to be the join between two sets of constraints $\Phi_1, \Phi_2$ and $\uplus$ to be the join between two peripheral state contexts $A_1, A_2$.

We define $\Phi(x)$ to refer to all of the constraints involving peripheral $x$. 
 A peripheral state context $A$ is associated with a set of constraints $\Phi$ if for each peripheral $p$, $A(p)$ exists and the set of constraints $\Phi(p)$ only use type variables found in $A[p]$.
Given the peripheral state contexts $A_1, A_2$ associated with $\Phi_1, \Phi_2$ respectively, we define $\Phi_1 \oplus \Phi_2$ as the following.

\sai{I don't think we need these rules}
\begin{mathpar}
    \inferrule*[left=Eq-Type-Variable]{
     \alpha_1 = \alpha_2 \\ \Phi_3|_{\alpha} = \Phi_1|_{\alpha_1} \land \Phi_2|_{\alpha_2} \\ \Phi_3' = \Phi_1' \oplus \Phi_2' 
    }{
    \alpha_1, \alpha_2 \vdash \Phi_1|_{\alpha_1}, \Phi_1' \oplus \Phi_2|_{\alpha_2}, \Phi_2' = \Phi_3|_{\alpha_1}, \Phi_3'
    }
    
    \inferrule*[left=NotEq-Type-Variable]{
     \alpha_1 \neq \alpha_2 \\ \alpha_3 \text{ fresh} \\ \Phi_3|_{\alpha_3} = \Phi_1|_{\alpha_1} \wedge \Phi_2|_{\alpha_2} \wedge (\alpha_3 = \alpha_1 \vee \alpha_2)
    }{
    \alpha_1, \alpha_2 \vdash \Phi_1|_{\alpha_1}, \Phi_1' \oplus \Phi_2|_{\alpha_2}, \Phi_2' = \Phi_3|_{\alpha_3}, \Phi_3'
    }
\end{mathpar}




We define the join between two peripheral state contexts, $A_1 \uplus A_2$ as follows.
\begin{mathpar}
\inferrule*[left=Top Level Join]
{
A_1 = p, A_1' \\ A_2 = p, A_2' \\ \alpha_0 \text{ fresh} \\ A' = p : [\alpha_0], \cdot \\ \Phi_1, \Phi_2 \vdash A_1[p] \uplus A_2[p] = A'[p], \Phi' \\ \Phi_1, \Phi_2, \Phi' \vdash A_1' \uplus A_2' = A'
}
{
\Phi_1, \Phi_2, \cdot \vdash A_1 \uplus A_2 = A', \Phi'
}

\sai{I am using $\sigma_1, \sigma_2$ to represent intermediate states that are between the prefix and the top of the stack}

\inferrule*[left=Stack Join] 
{ \pi = \m{prefix}(A_1[p], A_2[p]) \\ A_1[p] = \alpha_1 :: \sigma_1 :: \pi \\ A_2[p] = \alpha_2 :: \sigma_2 :: \pi \\ \alpha' \text{ fresh} \\ \Phi' = (\Phi_1 \land \Phi_2) \land \{ \alpha' = \alpha_1 \lor \alpha_2 \} \\ A'[p] = \alpha' :: \sigma_1 :: \sigma_2 :: \pi
} 
{ \Phi_1, \Phi_2 \vdash A_1[p] \uplus A_2[p] = A'[p], \Phi' 
}

\inferrule*[left=Empty]
{  }
{
\cdot \uplus \cdot = \cdot
}

\inferrule*[left=One Side Empty]
{ }
{A_1 \uplus \cdot = A_1}

\inferrule*[left=Symmetry]
{ }
{A_1 \uplus A_2 = A_2 \uplus A_1}
\end{mathpar}

We also define $\m{solve}(\Phi)$ to a function that takes in a set of constraints $\Phi$ and returns a solution $\varepsilon$ in the form of $\alpha \rightarrow \{st\}$, where the solution satisfies the following constraints: \sai{i dont think these rules are exactly right but im trying to formalize my intuition}
\begin{mathpar}

\inferrule*[left=Solve-Empty]
{}
{\cdot \vdash \alpha \Downarrow \top}

\inferrule*[left=Solve-Eq]
{}
{\alpha = \Vec{s} \vdash \alpha \Downarrow \Vec{s}}

\inferrule*[left=Solve-Leq]
{}
{\alpha \leq st \vdash \alpha \Downarrow \{\, s \mid s \leq st \,\}}

\inferrule*[left=Solve-Subset]
{}
{\alpha \subseteq \Vec{s} \vdash \alpha \Downarrow \Vec{s}}

\inferrule*[left=Solve-Hook]
{}
{\alpha \hookrightarrow st \vdash \alpha \Downarrow \mathsf{policy}(st)}

\inferrule*[left=Solve-And]
{
\varphi_1 \vdash \alpha \Downarrow S_1 \\
\varphi_2 \vdash \alpha \Downarrow S_2
}
{
\varphi_1 \wedge \varphi_2 \vdash \alpha \Downarrow S_1 \cap S_2
}

\inferrule*[left=Solve-Or]
{
\varphi_1 \vdash \alpha \Downarrow S_1 \\
\varphi_2 \vdash \alpha \Downarrow S_2
}
{
\varphi_1 \vee \varphi_2 \vdash \alpha \Downarrow S_1 \cup S_2
}
\end{mathpar}

Command state inference rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, A, \Phi \vdash c \rightarrow A', \Phi'$}
\end{aligned}
$$


\begin{mathpar}
\inferrule*[left=T-Transition\(_\textit{inf}\)] 
{ \tctx, A, \Phi \vdash x : \rho \\ A(x) = \alpha_0 \\ \alpha_1 \text{ fresh} \\ \Phi' = \Phi \land \alpha_0 \leq st \land \alpha_1 = st \\ A'[x] = \alpha_1 :: A[x]
} 
{ 
\tctx, A,\Phi \vdash \text{transition}(x, st) : \text{unit} \rightarrow A', \Phi' 
}

\inferrule*[left=T-Downgrade\(_\textit{inf}\)]
{
\tctx, A, \Phi \vdash x : \rho \\ A(x) = \alpha_0 \\ \alpha_1 \text{ fresh} \\ \Phi' = \Phi \land \alpha_0 \hookrightarrow st \land \alpha_1 = st \\ A'[x] = \alpha_1 :: A[x]
}
{ 
\tctx, A, \Phi \vdash \text{downgrade}(x, st) : \text{unit} \rightarrow A', \Phi'
}

\inferrule*[left=T-If\(_\textit{inf}\)]
{
\tctx \vdash e : \text{bool} \\ \tctx, A, \Phi \vdash c_1 : \rightarrow A_1, \Phi_1\\ \tctx, A, \Phi \vdash c_2 \rightarrow A_2, \Phi_2 \\  A^*, \Phi^* = A_1 \uplus A_2
}
{
\tctx, A, \Phi \vdash \text{if } e \text{ then } c_1 \text{ else } c_2: \tau \rightarrow A^*, \Phi^*
}

\inferrule*[left=T-Seq\(_\textit{inf}\)]
{
\tctx, A, \Phi \vdash c_1 \rightarrow A', \Phi' \\ \tctx, A', \Phi' \vdash c_2 \rightarrow A'', \Phi''
}
{
\tctx, A, \Phi \vdash c_1; c_2 \rightarrow A'', \Phi''
}

\inferrule*[left=T-Call\(_\textit{inf}\)]
{
\tctx(f) = (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \\ \tctx \vdash e : \tau_1 \\ A(p) = \alpha \\ \alpha' \text{ fresh} \\ \Phi' = \Phi \land \alpha \subseteq \Vec{s_1} \land \alpha' \subseteq \Vec{s_2} \\ A'[p] = \alpha' :: A[p]
}
{
\tctx, A, \Phi \vdash \text{let } x = f(e, p) \rightarrow A', \Phi'
}

\inferrule*[left=T-Atomic\(_\textit{inf}\)]
{
\forall i \in [1, \dots, n], A(p_i) = \alpha_i \\ \varphi = \bigwedge_{i = 1}^n \alpha_i \subseteq \Vec{s_i} \\ \Phi^* = \Phi \wedge \varphi \\ \tctx, A, \Phi^* \vdash c \rightarrow A', \Phi'
}
{
\tctx, A, \Phi \vdash \text{atomic}\{p_1: \Vec{s_1}, \dots, p_n: \Vec{s_n} \}(c) \rightarrow A', \Phi'
}

\inferrule*[left=T-Fun\(_\textit{inf}\)] 
{ \alpha_{\text{in}} \text{ fresh} \\ A = p : [\alpha_{\text{in}}] \\ \tctx, A, \cdot \vdash c \rightarrow A_f, \Phi_f \\ A_f(p) = \alpha_{\text{out}} \\ \Vec{s}_o = \m{solve}(\Phi_f, \alpha_{\text{out}}) \\ \Vec{s}_i = \m{solve}(\Phi_f, \alpha_{\text{in}}) \\ \tau_f = (\tau_1, \Vec{s}_i) \rightarrow (\tau_2, \Vec{s}_o)
} 
{ \tctx \vdash \text{fn } f(x, p) \ \{c; ret := e\} : \tau_f }

\end{mathpar}

\sai{state inference rules end here}

\sai{AARA system starts here}


Command typing rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, \pctx \vdash c: \tau \xrightarrow{C} \tctx', \pctx'$}
\end{aligned}
$$

Expression typing rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, \pctx \vdash e: \tau, C $}
\end{aligned}
$$


\begin{mathpar}

\inferrule*[left=T-Var]
{ \tctx(x) = \tau }
{ \tctx, \pctx \vdash x : \tau, C_v }


\inferrule*[left=T-BinOp]
{
\tctx,\pctx \vdash e_1 : \tau_1, C_1 \\ \tctx,\pctx \vdash e_2 : \tau_2, C_2 \\ \text{binop} : \tau_1 \times \tau_2 \xrightarrow{C_b} \tau
}
{
\tctx,\pctx \vdash e_1 \ \text{binop}\ e_2 : \tau, C_1 + C_2 + C_b
}

\inferrule*[left=T-PeriphDecl]
{
| \langle s_0,\ldots s_n \rangle | \geq 1 \\ \forall s' \hookrightarrow s \in D, s' > s
}
{
\tctx, \pctx \vdash \text{id} \{\langle s_{0},s_{1},\ldots,s_{n}\rangle, <, D \} : \text{unit} \Rightarrow \tctx[\text{id} : \rho], \pctx
}

\inferrule*[left=T-Let]
{ \tctx,\pctx \vdash e : \tau, C_e }
{ 
\tctx,\pctx \vdash \text{let } x = e : \text{unit} \xrightarrow{C_l + C_e} \tctx[x : \tau] , \pctx
}

\inferrule*[left=T-Call]
{
\tctx(f) = (\tau_1, \Vec{s_1}) \xrightarrow{\Phi_f} (\tau_2, \Vec{s_2}) \\ \tctx,\pctx \vdash e : \tau_1 \\ \pctx(p) = \Vec{s} \\ \Vec{s} \subseteq s_1 \\ C_f = \Phi_f[\Vec{s}] \\ C = C_f + C_a + \max(\forall s_i \in \Vec{s}, \m{cost}(s_i, s_1))
}
{
\tctx,\pctx \vdash \text{let } x = f(e, p) : \text{unit} \xrightarrow{C} \tctx[x : \tau_2], \pctx[p: s_2]
}

\inferrule*[left=T-Transition]
{
\tctx,\pctx \vdash x : \rho \\ \pctx(x) = \Vec{s} \\ \forall s_i\in \Vec{s}, s_i \leq st \\ C = \max(\forall s_i \in \Vec{s}, \m{cost}(s_i, st))
}
{ 
\tctx,\pctx \vdash \text{transition}(x, st) : \text{unit} \xrightarrow{C} \tctx, \pctx[x : st]
}

\inferrule*[left=T-Downgrade]
{
\tctx,\pctx \vdash x : \rho \\ \pctx(x) = \Vec{s} \\ \forall s_i\in \Vec{s}, s_i \hookrightarrow st \in p(D) \\ C = \max (\forall s_i \in \Vec{s}, \m{cost}(s_i, st) )
}
{ 
\tctx,\pctx \vdash \text{downgrade}(x, st) : \text{unit} \xrightarrow{C} \tctx, \pctx[x : st]
}

\inferrule*[left=T-If]
{
\tctx,\pctx \vdash e : \text{bool} \\ \tctx,\pctx \vdash c_1 : \tau \xrightarrow{C_1} \tctx_1, \pctx_1 \\ \tctx,\pctx \vdash c_2 : \tau \xrightarrow{C_2} \tctx_2, \pctx_2 \\ \tctx^* = \tctx_1 \cup \tctx_2 \\ \pctx^* = \pctx_1 \cup \pctx_2 \\ C = \max(C_1, C_2)
}
{
\tctx, \pctx \vdash \text{if } e \text{ then } c_1 \text{ else } c_2: \tau \xrightarrow{C} \tctx^*, \pctx^*
}
\end{mathpar}
\begin{mathpar}
\inferrule*[left=T-Seq]
{
\tctx,\pctx \vdash c_1 : \tau_1 \xrightarrow{C'} \tctx', \pctx' \\ \tctx',\pctx' \vdash c_2 : \tau_2 \xrightarrow{C''} \tctx'', \pctx'' \\ C'_{\max} = \m{cost}(\pctx') \\ C = C' + C'' + C'_{\max}
}
{
\tctx,\pctx \vdash c_1 ; c_2 : \tau_2 \xrightarrow{C} \tctx'', \pctx''
}

\inferrule*[left=T-Atomic]
{
\forall i, \pctx(p_i) \subseteq \Vec{s_i} \\ \tctx,\pctx \vdash c : \tau \xrightarrow{C'} \tctx', \pctx' \\ C = [\sum_{i=1}^{n} \max(\forall s'_i \in \Vec{s_i}, \m{cost(s'_i)})] + C'
}
{ 
\tctx,\pctx \vdash \text{atomic}\{p_1: \Vec{s_1}, \dots, p_n: \Vec{s_n} \}(c) : \tau \xrightarrow{C} \tctx', \pctx'
}


    \inferrule*[left=T-FunDecl]
{
\tctx[x : \tau_1], \pctx[p: \Vec{s_1}] \vdash c: \tau' \xrightarrow{C_1} \tctx', \pctx' \\ \pctx'(p) = \Vec{s_2} \\ \tctx', \pctx' \vdash e : \tau_2, C_2 \\ \Phi_f = C_1(\Vec{s_1}) + C_2(\Vec{s_1})
}
{ \tctx,\pctx \vdash \text{fn } f(x, p) : (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \  \{c; ret := e\} \Rightarrow \tctx[f \mapsto (\tau_1, \Vec{s_1}) \xrightarrow{\Phi_f} (\tau_2, \Vec{s_2})], \pctx
}

\end{mathpar}
\sai{AARA system ends here}
\newpage
\sai{Typestate system starts here}

Command typing rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, \pctx \vdash c: \tau \Rightarrow \tctx', \pctx'$}
\end{aligned}
$$

Expression typing rules are of the form $$
\begin{aligned}
    \fbox{$\tctx, \pctx \vdash e: \tau $}
\end{aligned}
$$

\begin{mathpar}

\inferrule*[left=T-Var]
{ \tctx(x) = \tau }
{ \tctx, \pctx \vdash x : \tau }


\inferrule*[left=T-BinOp]
{
\tctx,\pctx \vdash e_1 : \tau_1 \\ \tctx,\pctx \vdash e_2 : \tau_2 \\ \text{binop} : \tau_1 \times \tau_2 \to \tau
}
{
\tctx,\pctx \vdash e_1 \ \text{binop}\ e_2 : \tau
}

\inferrule*[left=T-Let]
{ \tctx,\pctx \vdash e : \tau }
{ 
\tctx,\pctx \vdash \text{let } x = e : \text{unit} \Rightarrow \tctx[x : \tau] , \pctx
}

\inferrule*[left=T-Call]
{
\tctx(f) = (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \\ \tctx,\pctx \vdash e : \tau_1 \\ \pctx(p) = \Vec{s} \\ \Vec{s} \subseteq s_1
}
{
\tctx,\pctx \vdash \text{let } x = f(e, p) : \text{unit} \Rightarrow \tctx[x : \tau_2], \pctx[p: s_2]
}

\inferrule*[left=T-Transition]
{
\tctx,\pctx \vdash x : \rho \\ \pctx(x) = \Vec{s} \\ \forall s_i\in \Vec{s}, s_i \leq st
}
{ 
\tctx,\pctx \vdash \text{transition}(x, st) : \text{unit} \Rightarrow \tctx, \pctx[x : st]
}

\inferrule*[left=T-Downgrade]
{
\tctx,\pctx \vdash x : \rho \\ \pctx(x) = \Vec{s} \\ \forall s_i\in \Vec{s}, s_i \hookrightarrow st \in p(D)
}
{ 
\tctx,\pctx \vdash \text{downgrade}(x, st) : \text{unit} \Rightarrow \tctx, \pctx[x : st]
}

\inferrule*[left=T-If]
{
\tctx,\pctx \vdash e : \text{bool} \\ \tctx,\pctx \vdash c_1 : \tau \Rightarrow \tctx_1, \pctx_1 \\ \tctx,\pctx \vdash c_2 : \tau \Rightarrow \tctx_2, \pctx_2 \\ \tctx^* = \tctx_1 \cup \tctx_2 \\ \pctx^* = \pctx_1 \cup \pctx_2 
}
{
\tctx, \pctx \vdash \text{if } e \text{ then } c_1 \text{ else } c_2 \Rightarrow \tctx^*, \pctx^*
}

\inferrule*[left=T-Seq]
{
\tctx,\pctx \vdash c_1 : \tau_1 \Rightarrow \tctx', \pctx' \\ \tctx',\pctx' \vdash c_2 : \tau_2 \Rightarrow \tctx'', \pctx''
}
{
\tctx,\pctx \vdash c_1 ; c_2 : \tau_2 \Rightarrow \tctx'', \pctx''
}

\inferrule*[left=T-Atomic]
{
\forall i, \pctx(p_i) \subseteq \Vec{s_i} \\ \tctx,\pctx \vdash c : \tau \Rightarrow \tctx', \pctx' 
}
{ 
\tctx,\pctx,S \vdash \text{atomic}\{p_1: \Vec{s_1}, \dots, p_n: \Vec{s_n} \}(c) : \tau \Rightarrow \tctx', \pctx'
}

\inferrule*[left=T-FunDecl]
{
\tctx[x : \tau_1], \pctx[p: \Vec{s_1}] \vdash c: \tau_2 \Rightarrow \tctx', \pctx' \\ \pctx'(p) = \Vec{s_2} \\ \tctx', \pctx' \vdash e : \tau_2
}
{ \tctx,\pctx \vdash \text{fn } f(x, p) : (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2}) \  \{c; ret := e\} \Rightarrow \tctx[f \mapsto (\tau_1, \Vec{s_1}) \rightarrow (\tau_2, \Vec{s_2})], \pctx
}

\end{mathpar}

\sai{Typestate system ends here}