\section{Language and Typing}

We present a simple imperative language. 
\[
\begin{array}{lcll}
\text{Declarations: }d & \bnfdef & c & \text{(command)} \\ & \bnfalt & \text{atomic}(c) & \text{(atomic)} \\ & \bnfalt & \text{fn } f(\Vec{x_{p}}) : \Vec{x_{r}} \ \{c\} & \text{(function)} \\ & \bnfalt & d_1 \ d_2 & \text{(sequence)}
\end{array}
\]
\[
\begin{array}{lcll}
\text{Commands: }c & \bnfdef & e & \text{(expression)} \\ & \bnfalt & \text{let } x = e & \text{(let)} \\
  & \bnfalt &\text{let } x = f(\Vec{e}) & \text{(function call)} \\
  & \bnfalt & \text{share } x \text{ as } x_1, x_2 \text{ in } c & \text{(share)} \\ 
  & \bnfalt & \text{if } e \text{ then } c_1 \text{ else } c_2 & \text{(branch)} \\
    & \bnfalt & \text{transition}(x, \text{st}) & \text{(transition)} \\
    & \bnfalt & c_1; c_2 & \text{(command seq)}
\end{array}
\]
\[
\begin{array}{lcll}
\text{Expressions: }e & \bnfdef & x & \text{(variable)}  \\
    & \bnfalt & v & \text{(value)} \\
    & \bnfalt & i_1 \text{ binop } i_2 & \text{(binary operation)} 
\end{array}
\]

Our judgments use the following additional constructs. 
\[
\begin{array}{llcl}
\textit{Typing Context} & \tctx & \bnfdef & x \rightarrow \tau, \tctx \bnfalt \cdot
\\ 
\textit{Types} & \tau & \bnfdef & \text{int} \bnfalt \text{bool} \bnfalt \tau_1 \rightarrow \tau_2 \bnfalt \rho 
\\
\textit{Peripheral} & p & \bnfdef & (\langle s_{0},s_{1},\ldots,s_{n}\rangle, <, D)
\\
\textit{Downgrade policy} & D & \bnfdef & s' \hookrightarrow^q s, D \bnfalt \cdot
\\
\textit{Downgrade condition} & q & \bnfdef & d \bnfalt \textbf{t} \bnfalt \textbf{f} \bnfalt q_1 \land q_2 \bnfalt \neg q \bnfalt q_1 \lor q_2
\\
\textit{Peripheral Context} & \pctx & \bnfdef &  p \rightarrow s_{\mt{curr}}, \pctx \bnfalt \cdot
\end{array}
\]
A downgrade policy $s' \hookrightarrow^q s$ means that a peripheral in state $s'$ can transition to state $s$ when condition $q$ is met, assuming that $s' > s$. A downgrade condition $q$ consists of a formula in proposition logic using base conditions $d$. We also assume the existence of the cost functions 
$\m{cost}(s_{i},s_{j})$ = transition cost between \(s_{i},s_{j}\) when
\(s_{i} \leq s_{j}\) and 
$\m{cost}(s_{i})$ = cost of being in state \(s_{i}\).
We define a join between the peripheral typing contexts $\pctx_1 \lub \pctx_2$ as follows.
\begin{mathpar}
\inferrule{
    s_3 = s_1 \lub s_2 \\ \pctx_3 = \pctx_1' \lub \pctx_2' \\ \m{dom}(\pctx_1') = \m{dom}(\pctx_2') 
}
{  p \rightarrow s_1, \pctx_1' \lub p \rightarrow s_2, \pctx_2' = p \rightarrow s_3, \pctx_3 }
\end{mathpar}
where the $s_1 \lub s_2$ is a standard notion of a lattice join, that is, 
\(s_{i} \lub s_{j} = s_{j}\) if \(s_{i} < s_{j}\), where the state lattice must have a unique \(\top\) element that is
the least upper bound of all the elements.
In words, the join of two peripheral contexts is a new context whose
elements are the join of the current state of each peripheral in the
context, and $\m{dom}(\pctx') = \m{dom}(\pctx'')$.

For now, we will assume that we only have one peripheral.
\todo{Finish the typing rule for functions}

\begin{mathpar}
\inferrule*[right=T-Call]
{
    \tctx(f): \tau_1 \xrightarrow{C_f} \tau_2 \\ \tctx_0 = \tctx, \forall i.\;
  \tctx_{i-1}, \pctx_{i-1}, S_{i-1} \vdash e_i : \tau_i \xrightarrow{C_i} \tctx_i, \pctx_i, S_i   \\ C = \sum_i C_i + C_f
}
{
  \tctx, \pctx, S \vdash
  \text{let } x = f(\Vec{e})
  \xrightarrow{C}
  \tctx[x \mapsto \tau_2], \pctx', S'
}

\todo{update the rest of these rules}

\inferrule*[right=T-Seq]
{
  \tctx, \pctx, s_{\max} \vdash e_1 : \tau_1 \xrightarrow{C_1} \pctx', s'_{\max} \\
  C_{1\text{-max}} = \text{cost}(s_{\max}) \\
  \tctx, \pctx', s'_{\max} \vdash e_2 : \tau_2 \xrightarrow{C_2} \pctx'', s''_{\max} \\
  C_{2\text{-max}} = \text{cost}(s'_{\max}) \\
  C = C_1 + C_2 + C_{1\text{-max}} + C_{2\text{-max}}
}
{
  \tctx, \pctx, s_{\max} \vdash i_1; i_2 : \tau_2 \xrightarrow{C} \pctx'', s''_{\max}
}

\inferrule*[right=T-Atomic]
{
  \tctx, \pctx, s_{\max} \vdash i : \tau \xrightarrow{C_1} \pctx', s'_{\max} \\
  C_{\max} = \text{cost}(s'_{\max}) \\
  C = C_1 + C_{\max}
}
{
  \tctx, \pctx, s_{\max} \vdash \text{atomic}(i) : \tau \xrightarrow{C} \pctx', s'_{\max}
}

\inferrule*[right=T-Branch]
{
  \tctx, \pctx, s_{\max} \vdash i : \text{bool} \xrightarrow{C'} \pctx, s_{\max} \\
  \tctx, \pctx, s_{\max} \vdash e_1 : \tau \xrightarrow{C_1} \pctx_1, s^1_{\max} \\
  \tctx, \pctx, s_{\max} \vdash e_2 : \tau \xrightarrow{C_2} \pctx_2, s^2_{\max}\\
  C = C' + \max(C_1, C_2) \\
  \pctx' = \pctx_1 \sqcup \pctx_2 \\
  s'_{\max} = s^1_{\max} \lub s^2_{\max}
}
{
  \tctx, \pctx, s_{\max} \vdash \text{if } i \text{ then } e_1 \text{ else } e_2 : \tau \xrightarrow{C} \pctx', s'_{\max}
}

\inferrule*[right=T-Transition]
{
  \tctx, \pctx \vdash x : \rho \\
  \pctx(x) = s_i \\
  s_i \le s \\
  C_t = \text{cost}(s_i, s) \\ s'_{\max} = s_{\max} \lub s
}
{
  \tctx, \pctx, s_{\max} \vdash \text{transition}(x, s) : \text{Unit} \xrightarrow{C_t} \pctx[x : s], s'_{\max}
}

\inferrule*[right=T-Binop]
{
\tctx, \pctx, s_{\max} \vdash e_1 : \text{int} \xrightarrow{C_1} \pctx, s_{\max} \\ \tctx, \pctx, s_{\max} \vdash e_2 : \tau \xrightarrow{C_2} \pctx, s_{\max} \\
C = C_1 + C_2 + C_{bin}
}
{
\tctx, \pctx, s_{\max} \vdash i_1 \text{ binop } i_2 : \tau \xrightarrow{C} \pctx, s_{\max}
}

\inferrule*[right=T-Var]
{
  \tctx(x) = \tau
}
{
\tctx,\pctx,s_{\max} \vdash x : \tau \xrightarrow{C_v} \pctx, s_{\max}
}

\end{mathpar}
